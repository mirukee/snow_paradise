나는 지금 'Snow Paradise'라는 Flutter 앱을 개발 중이야.
프로젝트의 목표, 현재 진행 상황, 기술 스택을 반영해 앞으로의 개발을 도와줘.

# Communication Settings
1. **Language:** You must ALWAYS respond in **Korean (한국어)**.
2. **Code Comments:** Write all code comments in **Korean** to help understanding.
3. **Technical Terms:** Use English for standard technical terms (e.g., BuildContext, Stream, Future) but explain them in Korean.

## 1. 프로젝트 개요 (Project Overview)
- **앱 이름:** Snow Paradise
- **목표:** 스키/스노우보드 유저들을 위한 중고 거래 및 커뮤니티 플랫폼 (당근마켓 스타일)
- **타겟 유저:** 겨울 스포츠(스키, 보드) 마니아

## 2. 기술 스택 (Tech Stack)
- **Framework:** Flutter (Dart)
- **State Management:** Provider (ChangeNotifier 기반)
- **UI Style:** Material 3, Custom 'Stitch' Design (Ice Blue: 0xFF3E97EA)
- **Backend:** Firebase (firebase_core, firebase_auth, cloud_firestore, firebase_storage, firebase_messaging)
- **Key Packages:** `google_sign_in`, `image_picker`, `flutter_local_notifications`, `intl`
- **Architecture:** MVVM 패턴 지향 (Screens -> Providers -> Services -> Models)

## 3. 코드 컨벤션 및 아키텍처 규칙 (Code Convention & Architecture Rules)
- **Service Layer Role:**
    - `ProductService`: 상품 데이터 캐싱 및 상태 관리. **(주의: 현재 전체 데이터를 로드하므로 리팩토링 필요)**
    - `ChatService`: 실시간 채팅 및 메시지 동기화 담당.
- **카테고리 및 속성 관리:**
    - 모든 카테고리, 서브카테고리, 동적 속성(Attributes) 정의는 `lib/constants/categories.dart` 내의 `CategoryConstants`와 `CategoryAttributes` 클래스에서 관리한다.
    - 화면(UI) 내에서 카테고리 리스트나 속성 옵션을 **하드코딩하지 않는다**.
- **동적 속성 UI:**
    - 상품 등록, 수정, 필터링 등 속성 입력이 필요한 UI는 반드시 `lib/widgets/dynamic_attribute_form.dart`의 `DynamicAttributeForm` 위젯을 재사용하여 일관성을 유지한다.
- **데이터 모델:**
    - `Product` 모델의 `specs` 필드(`Map<String, String>`)를 사용하여 카테고리별 상이한 속성을 유연하게 저장한다.
    - 검색이나 주요 로직에 필요한 핵심 속성(브랜드, 사이즈, 연식 등)은 `specs`와 별도로 최상위 필드에도 매핑하여 저장한다.
- **Lint 규칙:**
    - `flutter analyze` 경고를 최소화한다.
    - `withOpacity` 대신 `.withValues(alpha: ...)` 사용 등 최신 Flutter API를 따른다.

## 4. 현재 구현된 기능 (Current Status)
- **상품 관리:**
    - 다중 이미지 업로드 및 슬라이더 뷰.
    - 동적 카테고리(대분류 > 소분류) 및 속성(길이, 쉐입, 브랜드 등) 입력 시스템.
    - 상품 등록, 수정, 상세 조회, 삭제, 상태 변경(예약중, 판매완료 등).
- **쇼핑/탐색:**
    - 카테고리별 상품 리스트 및 서브카테고리 탭.
    - 동적 속성 기반 상세 필터링(Bottom Sheet).
    - 2열 그리드 뷰 및 찜(좋아요) 기능.
    - **최근 검색어 저장 및 관리** (`shared_preferences` 기반, 개별/전체 삭제 지원).
- **안전 정책:**
    - **신고하기:** `ReportDialog` 위젯을 통해 사용자/상품 신고 가능. 신고 데이터는 Firestore `reports` 컬렉션에 저장.
    - **차단하기:** 판매자 프로필에서 사용자 차단/차단 해제 가능. 차단된 사용자의 상품은 목록에서 자동 숨김.
- **알림:**
    - FCM 푸시 알림 (채팅 및 좋아요 알림 지원).
    - **알림 센터:** 알림 히스토리 조회, 읽음 처리, 개별/전체 삭제 기능.
- **관리자 기능:**
    - 별도 진입점(`main_admin.dart`)으로 관리자 대시보드 제공.
    - 사용자 목록, 상품 목록, 공지사항, 이용약관 관리.
    - **신고 목록 조회:** `AdminReportListScreen`에서 접수된 신고 확인 가능.
- **기타:**
    - 구글/게스트 로그인, 프로필 수정, 채팅(기본 기능).
    - **마이페이지 판매내역:** `products` 컬렉션에서 `sellerId` 기준으로 직접 조회하며, **마이페이지 탭이 활성화된 경우에만** 스트림을 구독한다.

## 5. 미완/리스크 항목 (Gap/Risk)
- **Firebase 비용/성능 리스크 (CRITICAL):**
    - 일반 모드는 `fetchProducts`에서 **최신 N개만 제한 구독**하고, 목록 화면은 **페이징 기반**으로 전환됨. 다만 `productList`에 의존하는 화면은 **최신 N개 범위를 넘는 데이터 누락** 가능성이 있음(예: 마이페이지 판매내역). 필요 시 별도 쿼리/페이징으로 전환.
    - `ChatService`의 `markAsRead`가 읽지 않은 메시지 수만큼 쓰기 작업(Batch)을 수행. 채팅방 활성화 시 쓰기 비용 스파이크 가능성.
- **보안 리스크 (CRITICAL):**
    - 관리자 로그인(`AdminAuthProvider`)이 클라이언트 사이드에서 평문 비밀번호를 비교함. `admin/settings` 문서의 읽기 권한이 탈취될 경우 비밀번호 노출 위험. Backend 검증(Cloud Functions) 또는 Auth Custom Claims 도입 필요.
- **거래 프로세스:** 정식 거래 플로우(구매 요청, 결제 연동)는 미구현. 현재는 채팅을 통한 직거래 방식.
- **관리자 고도화:** 신고 처리(해결/삭제) 기능, 통계 대시보드.

## 6. MVP 우선순위 (Next Steps)
1. **관리자 기능 고도화:** 신고 처리 액션(해결/삭제), 통계 대시보드.
2. **사용자 경험:** 인기 검색어 표시, 검색 자동완성 개선.
3. **성능:** 상품 목록 페이징, 이미지 캐싱 전략.

## 7. 성능/비용 개선 가이드 (필수 준수)
- **ProductService 데이터 로딩 정책:**
  - 앱 시작 시 `products` 전체를 `snapshots()`로 구독하지 않는다.
  - 홈/카테고리/검색은 **페이징 기반**으로 로딩하고, 일반 모드는 **최신 N개만 제한 구독**한다(관리자 모드만 전체 구독).
  - 페이징 목록 화면은 반드시 `fetchProductsPaginated(..., contextKey: ...)`를 사용해 **화면별 컨텍스트를 구분**한다.
  - 목록/검색 결과는 `productList`가 아닌 **`paginatedProducts`를 기준**으로 렌더링한다.
  - 카테고리/검색 필터는 가능한 한 **Firestore 쿼리(where/orderBy/limit)**로 내려보내 로컬 필터링 의존을 줄인다.
  - 자동완성/검색 추천은 전체 로컬 리스트 의존을 피하고, **집계 컬렉션(예: search_keywords)** 기반으로 조회한다.
  - 단건 상세 조회는 전체 리스트에 의존하지 말고 **단건 Firestore 조회 경로**를 별도 유지한다.
  - 마이페이지 판매내역/관심목록 카운트는 `productList`에 의존하지 않고 **직접 쿼리**하며, 탭 비활성 시 **Stream 구독을 중지**한다.
- **ChatService 읽음 처리 정책:**
  - `markAsRead`에서 **모든 메시지 개별 업데이트를 금지**한다.
  - 채팅방 문서에 `lastReadAtBuyer/lastReadAtSeller`를 저장하고, 메시지 표시 시 `createdAt <= lastReadAt` 비교로 읽음 상태를 계산한다.
  - 읽음 표시는 **내가 보낸 최신 메시지 1개** 기준으로만 표시한다.
  - `markAsRead`는 `unreadCount > 0` 또는 `lastReadAt < latestMessage.createdAt`일 때만 호출하고, **debounce(예: 300ms)**를 적용한다.
  - 부득이하게 per-message 업데이트가 필요하면 **최근 N개만 업데이트**한다.
- **ChatService 목록 로딩 정책:**
  - `chat_rooms`는 `participants array-contains` + `orderBy(lastMessageTime desc)` + `limit` 쿼리로 구독한다.
  - 채팅 목록 화면은 **limit 기반 pagination**으로 스크롤 시 추가 로딩한다.

## 8. 검색/필터 설계 (v1, 비용 최적화 기준)
- **필터 프로파일(소분류별 핵심 필터):** 서버 Query에서 거를 필터는 3~5개로 제한한다.
  - 스키/스키: 브랜드 + 길이 + 쉐입 + 연식
  - 스키/부츠: 브랜드 + 사이즈 + 연식
  - 스노우보드/데크: 브랜드 + 길이 + 쉐입 + 연식
  - 스노우보드/바인딩: 브랜드 + 사이즈 + 연식
  - 스노우보드/부츠: 브랜드 + 사이즈 + 연식
  - 의류/상의·하의·일체형: 브랜드 + 사이즈 + 성별 + 연식
  - 장비/보호대(헬멧/보호대/장갑): 브랜드 + 사이즈
  - 장비/보호대(고글): 브랜드
  - 속성 미정/불필요 소분류(스키/폴, 스키/세트, 스노우보드/세트 등): 가격 + 직거래 장소만 적용
- **버킷(Bucket) 규칙:**
  - `priceBucket`: 10만원 단위
  - `lengthBucket`: 5cm 단위
  - `year`: UI는 `24/25`, `23/24` 같은 값, 다중 선택 가능(최대 2개)
- **가격 범위 정책:**
  - UI는 연속 범위만 허용한다.
  - `whereIn` 최대 10개 제한으로 인해, 버킷 수가 10개를 초과하면 **가격 필터를 생략**하고 로컬에서 최종 필터링한다.
- **직거래 장소 정책:**
  - 도시 + 리조트 혼합 선택 가능, **최대 2개**까지 허용한다(OR 조건).
  - `tradeLocationKey`는 `city:seoul` / `resort:high1` 형태로 통일한다.
- **filterTokens 규칙:**
  - `filterTokens`에 핵심 필터 + `tradeLocationKey` 조합을 저장한다.
  - 필터 미선택은 `*`로 처리하여 부분 매칭을 지원한다(예: `b=salomon|l=150|s=*|y=24/25|loc=city:seoul`).
  - 연식 미선택(무관)은 `y=*`로 처리한다.
- **Query 구성:**
  - 기본: `where(category)` + `where(priceBucket in ...)` + `where(filterTokens array-contains ...)` + `orderBy(createdAt desc)` + pagination.
  - 연식/직거래 장소 다중 선택 시 쿼리를 분할하고 결과를 **병합/중복 제거/정렬**한다.
  - 정렬은 최신순을 기본으로 하고, 가격순 정렬은 비용 이슈가 없을 때만 추가 검토한다.
  - 텍스트 검색은 **필터 결과 내부에서만** 로컬 매칭으로 처리한다(서버 Query에서 텍스트 검색은 사용하지 않는다).

## 9. 검색 로직 구현 상세 (ProductService 기준)
- **저장 필드(문서):** 상품 생성/수정 시 `priceBucket`, `lengthBucket`, `filterTokens`, `tradeLocationKey`를 함께 저장한다.
  - `priceBucket`: `price ~/ 100000`
  - `lengthBucket`: 길이값을 5cm 단위로 버킷화(예: 151 -> 150)
  - `filterTokens`: 핵심 필터 + `loc` 조합을 **실값/`*` 와일드카드**로 확장한 토큰 배열
- **토큰 생성 규칙(상품 저장 시):**
  - 소분류의 **필터 프로파일**에서 토큰 키 순서를 만들고(`CategoryAttributes.getFilterProfile`), 마지막에 `loc`를 항상 추가한다.
  - `y`(연식)는 `specs['year']` 우선, 없으면 `product.year`를 사용한다.
  - 길이 속성은 버킷 값(문자열)만 사용한다.
  - 각 키에 대해 **실값 + `*` 조합**을 만들어 `filterTokens` 배열을 생성한다.
- **검색 토큰 생성(조회 시):**
  - 필터가 전혀 없으면 토큰 생성 없이 `__all__`로 조회(= `arrayContains` 미사용).
  - 연식/직거래 장소 다중 선택은 **카테시안 곱**으로 토큰을 생성한다.
  - 길이 필터는 **단일값(버킷)일 때만** 토큰에 반영한다(범위는 로컬 필터).
- **가격 버킷 조회:**
  - `price`의 min/max로 버킷 범위를 만들고, **버킷 수가 10개 초과**면 서버 `whereIn`을 생략한다(로컬 필터만).
- **페이징/병합:**
  - `_pageSize=20`, 토큰마다 **개별 커서**(`_queryCursors[token]`)를 유지한다.
  - `loadMoreProducts`는 토큰별 쿼리를 병렬 실행 → 결과를 **docId 기준 병합/중복 제거** → `createdAt desc` 정렬 후 로컬 필터.
  - `queryRevision`으로 **이전 쿼리 결과가 섞이지 않도록** 가드한다.
- **로컬 필터 적용(`_applySearchFilters`):**
  - 상태(hidden 제외), subCategory, sellerId, price range, tradeLocationKeys, specs(단일/리스트/범위)를 검증한다.
  - 텍스트 검색은 title/brand/subCategory/description/specs에 대해 **로컬 contains**만 수행한다.
- **화면 컨텍스트:**
  - 모든 페이징 화면은 `fetchProductsPaginated(..., contextKey: ...)`를 사용한다.
  - `activeQueryKey`와 **현재 라우트/탭 활성 상태**를 확인해 자동 fetch 핑퐁을 방지한다.

## 10. Firestore 인덱스 관리
- 인덱스 정의는 `firestore.indexes.json`을 **단일 소스**로 관리한다.
- 배포는 `firebase deploy --only firestore:indexes`로 수행한다.
- 기존 레거시 인덱스(`products/keywords*`, `chat_rooms/participants+lastMessageTime`)는 **새 구조에서 사용하지 않으며 삭제됨**.

이 내용을 바탕으로 요청된 기능을 구현하고, 변경 사항과 다음 단계(테스트 등)를 간단히 안내해줘.
